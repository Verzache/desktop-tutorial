#caesar
import java.util.Scanner;
public class Main
{
 public static final String Alphabet = "abcdefghijklmnopqrstuvwxyz";
	
 public static String encrypt(String n, int s){
     String text = n.toLowerCase();
     String cipher = "";
     
     for(int i=0; i<text.length(); i++){
         int charpos = Alphabet.indexOf(text.charAt(i));
         int keyval = (s + charpos)%26;
         char replaceVal = Alphabet.charAt(keyval);
         cipher+= replaceVal;
     }
     
     return cipher;
 }
	
 public static String decrypt(String cipher, int s){
     String ciphertext = cipher.toLowerCase();
     String text = "";
     
     for(int i=0; i<ciphertext.length(); i++){
         int charpos = Alphabet.indexOf(ciphertext.charAt(i));
         int keyval = (charpos-s)%26;
         if(keyval <0){
             keyval=Alphabet.length() + keyval;
          }
         char replaceVal = Alphabet.charAt(keyval);
         text+= replaceVal;
     }
     return text;
 }
	
	
 public static void main(String args[]){
     Scanner sc = new Scanner(System.in);
     System.out.println("Enter plaintext: ");
     String text = new String();
     text = sc.next();
     String cipher = encrypt(text, 3);
     System.out.println("Encrypted Text: "+cipher);
     
     text = decrypt(cipher, 3);
     System.out.println("Decrypted Text: "+ text);
 }
	
}

#monoalphabetic
import java.util.Scanner;
public class Main
{
    public static char p[]  = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',
            'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
            'w', 'x', 'y', 'z' };
    public static char ch[] = { 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O',
            'P', 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'Z', 'X', 'C',
            'V', 'B', 'N', 'M' };
    public static String doEncryption(String s)
    {
        char c[] = new char[(s.length())];
        for (int i = 0; i < s.length(); i++)
        {
            for (int j = 0; j < 26; j++)
            {
                if (p[j] == s.charAt(i))
                {
                    c[i] = ch[j];
                    break;
                }
            }
        }
        return (new String(c));
    }
    public static String doDecryption(String s)
    {
        char p1[] = new char[(s.length())];
        for (int i = 0; i < s.length(); i++)
        {
            for (int j = 0; j < 26; j++)
            {
                if (ch[j] == s.charAt(i))
                {
                    p1[i] = p[j];
                    break;
                }
            }
        }
        return (new String(p1));
    }
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the message: ");
        String en = doEncryption(sc.next().toLowerCase());
        System.out.println("Encrypted message: " + en);
        System.out.println("Decrypted message: " + doDecryption(en));
        sc.close();
    }
}

#vernam
import java.io.*;
public class Main
{
    public static String encrypt(String text, String Key)
    {
        String ciphertext = "";
        int cipher[] = new int[Key.length()];
        for(int i=0; i<Key.length(); i++)
        {
            cipher[i] = text.charAt(i) - 'A' + Key.charAt(i)-'A';
        }
        for(int i=0; i<Key.length(); i++)
        {
            if(cipher[i]>25)
            {
                cipher[i] = cipher[i]-26;
            }
        }
        for(int i=0; i<Key.length(); i++)
        {
            int x = cipher[i] + 'A';
            ciphertext += (char)x;
        }
        return ciphertext;
    }
    public static String decrypt (String s, String Key)
    {
        String plaintext = "";
        int plain[] = new int[Key.length()];
        for(int i=0; i<Key.length(); i++)
        {
            plain[i] = s.charAt(i) - 'A'+Key.charAt(i)-'A';
        }
        for(int i=0; i<Key.length(); i++)
        {
            if(plain[i]<0)
            {
                plain[i] = plain[i]+26;
            }
        }
        for(int i=0; i<Key.length(); i++)
        {
            int x = plain[i] + 'A';
            plaintext += (char)x;
        }
        return plaintext;
    }
    public static void main (String[] args)
    {
        String plaintext = "Hello";
        String Key = "Money";
        String encrypttext = encrypt(plaintext.toUpperCase(),Key.toUpperCase());
        System.out.println("Encrypted message: "+encrypttext);
        System.out.println("Decrypted message: "+decrypt(encrypttext,Key.toUpperCase()));
    }
}

#playfair 
import java.util.*;
public class Main {
 
    // Removing the duplicate values from the key
    static String removeDuplicate(String s)
    {
 
        int j, index = 0, len = s.length();
 
        char c[] = s.toCharArray();
 
        for (int i = 0; i < len; i++) {
 
            for (j = 0; j < i; j++) {
 
                if (c[i] == c[j])
 
                    break;
            }
 
            if (i == j)
 
                c[index++] = c[i];
        }
 
        s = new String((Arrays.copyOf(c, index)));
 
        return s;
    }
 
    // Method 1
    // Removing the white spaces from string 'st'
    // which was replaced by the key as space.
    static String removeWhiteSpace(char[] ch, String key)
    {
 
        char[] c = key.toCharArray();
 
        // removing character which are input by the user
        // from string st
 
        for (int i = 0; i < c.length; i++) {
 
            for (int j = 0; j < ch.length; j++) {
 
                if (c[i] == ch[j])
 
                    c[i] = ' ';
            }
        }
 
        key = new String(c);
 
        key = key.replaceAll(" ", "");
 
        return key;
    }
 
    // Method 2
    // To make the pair for encryption in plaintext.
    static String makePair(String pt)
    {
 
        String s = "";
 
        char c = 'a';
 
        for (int i = 0; i < pt.length(); i++) {
 
            if (pt.charAt(i) == ' ')
 
                continue;
 
            else {
 
                c = pt.charAt(i);
 
                s += pt.charAt(i);
            }
 
            if (i < pt.length() - 1)
 
                if (pt.charAt(i) == pt.charAt(i + 1))
 
                    s += "x";
        }
 
        // If plain text length is odd then
        // adding x to make length even.
        if (s.length() % 2 != 0)
 
            s += "x";
 
        System.out.println(s);
 
        return s;
    }
 
    // Method 3
    // To find the position of row and column in matrix
    // for encryption of the pair.
    static int[] findIJ(char a, char b, char x[][])
    {
 
        int[] y = new int[4];
 
        if (a == 'j')
 
            a = 'i';
 
        else if (b == 'j')
 
            b = 'i';
 
        for (int i = 0; i < 5; i++) {
 
            for (int j = 0; j < 5; j++) {
 
                if (x[i][j] == a) {
 
                    y[0] = i;
 
                    y[1] = j;
                }
 
                else if (x[i][j] == b) {
 
                    y[2] = i;
 
                    y[3] = j;
                }
            }
        }
 
        if (y[0] == y[2]) {
 
            y[1] += 1;
 
            y[3] += 1;
        }
 
        else if (y[1] == y[3]) {
 
            y[0] += 1;
 
            y[2] += 1;
        }
 
        for (int i = 0; i < 4; i++)
 
            y[i] %= 5;
 
        return y;
    }
 
    // Method 4
    // To encrypt the plaintext
    static String encrypt(String pt, char x[][])
    {
 
        char ch[] = pt.toCharArray();
 
        int a[] = new int[4];
 
        for (int i = 0; i < pt.length(); i += 2) {
 
            if (i < pt.length() - 1) {
 
                a = findIJ(pt.charAt(i), pt.charAt(i + 1),
                           x);
 
                if (a[0] == a[2]) {
 
                    ch[i] = x[a[0]][a[1]];
 
                    ch[i + 1] = x[a[0]][a[3]];
                }
 
                else if (a[1] == a[3]) {
 
                    ch[i] = x[a[0]][a[1]];
 
                    ch[i + 1] = x[a[2]][a[1]];
                }
 
                else {
 
                    ch[i] = x[a[0]][a[3]];
 
                    ch[i + 1] = x[a[2]][a[1]];
                }
            }
        }
 
        pt = new String(ch);
 
        return pt;
    }
 
    // Method 5
    // Main driver method
    public static void main(String[] args)
    {
 
        // Creating an Scanner clas object to
        // take input from user
        Scanner sc = new Scanner(System.in);
 
        String pt = "instruments";
 
        // Key input
        String key = "monarchy";
 
        key = removeDuplicate(key);
 
        char[] ch = key.toCharArray();
 
        // Reading string array of Letters of english
        // alphabet as Playfair to implement
        String st = "abcdefghiklmnopqrstuvwxyz";
 
        st = removeWhiteSpace(ch, st);
 
        char[] c = st.toCharArray();
 
        // Matrix input using above key
        char[][] x = new char[5][5];
 
        int indexOfSt = 0, indexOfKey = 0;
 
        for (int i = 0; i < 5; i++) {
 
            for (int j = 0; j < 5; j++) {
 
                if (indexOfKey < key.length())
 
                    x[i][j] = ch[indexOfKey++];
 
                else
 
                    x[i][j] = c[indexOfSt++];
            }
        }
 
        // Printing Matrix
 
        for (int i = 0; i < 5; i++) {
 
            for (int j = 0; j < 5; j++)
 
                System.out.print(x[i][j] + " ");
 
            System.out.println();
        }
 
        // For getting encrypted output
 
        // Calling makePair() method over object created in
        // main()
        pt = makePair(pt);
 
        // Calling makePair() method over object created in
        // main()
        pt = encrypt(pt, x);
 
        // Print and display in the console
        System.out.println(pt);
    }
}

#railfence
import java.util.*;

public class pencil {
 
 
 public static void main(String arg[]){
  
  
  System.out.println("Enter the number of rails:");
  Scanner in=new Scanner (System.in);
  int rails=in.nextInt();

   
  
  System.out.println("Enter the plaintext for encryption");
  Scanner inn=new Scanner (System.in);
  String plaintext=inn.next();
  
  encryption(plaintext,rails);
 

  System.out.println("------------------Decryption process start----------");
  
  System.out.println("Enter the number of rails:");
  rails=in.nextInt();
  System.out.println("Enter the ciphertext for decryption:");
  String ciphertext=in.next();
  decryption(ciphertext,rails);
  
 }
 public static void encryption(String str,int rails){
  
  boolean checkdown=false;  //check whether it is moving downward or upward
  int j=0;
  int row=rails;                  // no of row is the no of rails entered by user
  int col=str.length();             //column length is the size of string
  char[][] a=new char[row][col];
  //we create a matrix of a of row *col size
  
  for(int i=0;i<col;i++){  //matrix visitin in rails order and putting the character of plaintext


   if(j==0||j==row-1)
    checkdown=!checkdown;
   a[j][i]=str.charAt(i);
   if(checkdown){
  
   
    j++;
    }
   else
   j--;
  }
  
  //visiting the matrix in usual order to get ciphertext
  for(int i=0;i<row;i++){
   for(int k=0;k<col;k++){
    System.out.print(a[i][k]+"  ");
   }
   System.out.println();
  }
  String en="";
  
  System.out.println("----------------------");
  for(int i=0;i<row;i++){
   for(int k=0;k<col;k++){
    if(a[i][k]!=0)
     en=en+a[i][k];
    
   }
   
  }
  System.out.println(en);//printing the ciphertext
  

 }
 
 
 
public static void decryption(String str,int rails){
 
 
 boolean checkdown=false;
 int j=0;
 int row=rails;
 int col=str.length();
 char[][] a=new char[row][col];
 
 //first of all mark the rails position by * in the matrix
 for(int i=0;i<col;i++){
  if(j==0||j==row-1)
   checkdown=!checkdown;
  
  
  
  a[j][i]='*';
  if(checkdown)j++;
  else j--;
 
 }
 

 //now enter the character of cipheetext in the matrix positon that have * symbol
 int index=0;
 
 for(int i=0;i<row;i++){
  for(int k=0;k<col;k++){
   
   
   if(a[i][k]=='*'&&index<str.length()){
   a[i][k]=str.charAt(index++);
   
 
  
   
   }
   
  }
  
 
 
 }
 
// visit each character in rails order as character are put in the encryption function
 for(int i=0;i<row;i++){
  for (int k=0;k<col;k++){
   System.out.print(a[i][k]+ "\t");
  }
  System.out.println();
 }
 
 checkdown=false;
 String s="";
 j=0;
 
 for(int i=0;i<col;i++){
  if( j==0||j==row-1)
   checkdown=!checkdown;
  
  
  s+=a[j][i];
  
 
  if(checkdown)j++;
  else j--;
 
 }
 
 
 System.out.print(s);//print the plaintext that was decrypted by rail fence cipher

 
}
}

#simple columnar 
import java.util.*;
import java.io.*;
import java.lang.*;

public class columnarTranspose {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        String line = System.getProperty("line.separator");
        scan.useDelimiter(line);

        System.out.print("1. Encryt 2.Decrypt : ");
        int option = scan.nextInt();
        switch (option) {
            case 1:
                System.out.print("Enter String:");
                String text = scan.next();

                System.out.print("Enter Key:");
                String key = scan.next();

                System.out.println(encryptCT(key, text).toUpperCase());
                break;
            case 2:
                System.out.print("Enter Encrypted String:");
                text = scan.next();

                System.out.print("Enter Key:");
                key = scan.next();

                System.out.println(decryptCT(key, text));
                break;
            default:
                break;
        }
    }

    public static String encryptCT(String key, String text) {
        int[] arrange = arrangeKey(key);

        int lenkey = arrange.length;
        int lentext = text.length();

        int row = (int) Math.ceil((double) lentext / lenkey);

        char[][] grid = new char[row][lenkey];
        int z = 0;
        for (int x = 0; x < row; x++) {
            for (int y = 0; y < lenkey; y++) {
                if (lentext == z) {
                    // at random alpha for trailing null grid
                    grid[x][y] = RandomAlpha();
                    z--;
                } else {
                    grid[x][y] = text.charAt(z);
                }

                z++;
            }
        }
        String enc = "";
        for (int x = 0; x < lenkey; x++) {
            for (int y = 0; y < lenkey; y++) {
                if (x == arrange[y]) {
                    for (int a = 0; a < row; a++) {
                        enc = enc + grid[a][y];
                    }
                }
            }
        }
        return enc;
    }

    public static String decryptCT(String key, String text) {
        int[] arrange = arrangeKey(key);
        int lenkey = arrange.length;
        int lentext = text.length();

        int row = (int) Math.ceil((double) lentext / lenkey);

        String regex = "(?<=\\G.{" + row + "})";
        String[] get = text.split(regex);

        char[][] grid = new char[row][lenkey];

        for (int x = 0; x < lenkey; x++) {
            for (int y = 0; y < lenkey; y++) {
                if (arrange[x] == y) {
                    for (int z = 0; z < row; z++) {
                        grid[z][y] = get[arrange[y]].charAt(z);
                    }
                }
            }
        }

        String dec = "";
        for (int x = 0; x < row; x++) {
            for (int y = 0; y < lenkey; y++) {
                dec = dec + grid[x][y];
            }
        }

        return dec;
    }

    public static char RandomAlpha() {
        //generate random alpha for null space
        Random r = new Random();
        return (char)(r.nextInt(26) + 'a');
    }

    public static int[] arrangeKey(String key) {
        //arrange position of grid
        String[] keys = key.split("");
        Arrays.sort(keys);
        int[] num = new int[key.length()];
        for (int x = 0; x < keys.length; x++) {
            for (int y = 0; y < key.length(); y++) {
                if (keys[x].equals(key.charAt(y) + "")) {
                    num[y] = x;
                    break;
                }
            }
        }

        return num;
    }

}

#des algorithm
import java.util.*;
 
public class Main {
    private static class DES {
        // CONSTANTS
        // Initial Permutation Table
        int[] IP
            = { 58, 50, 42, 34, 26, 18, 10, 2,  60, 52, 44,
                36, 28, 20, 12, 4,  62, 54, 46, 38, 30, 22,
                14, 6,  64, 56, 48, 40, 32, 24, 16, 8,  57,
                49, 41, 33, 25, 17, 9,  1,  59, 51, 43, 35,
                27, 19, 11, 3,  61, 53, 45, 37, 29, 21, 13,
                5,  63, 55, 47, 39, 31, 23, 15, 7 };
 
        // Inverse Initial Permutation Table
        int[] IP1
            = { 40, 8,  48, 16, 56, 24, 64, 32, 39, 7,  47,
                15, 55, 23, 63, 31, 38, 6,  46, 14, 54, 22,
                62, 30, 37, 5,  45, 13, 53, 21, 61, 29, 36,
                4,  44, 12, 52, 20, 60, 28, 35, 3,  43, 11,
                51, 19, 59, 27, 34, 2,  42, 10, 50, 18, 58,
                26, 33, 1,  41, 9,  49, 17, 57, 25 };
 
        // first key-hePermutation Table
        int[] PC1
            = { 57, 49, 41, 33, 25, 17, 9,  1,  58, 50,
                42, 34, 26, 18, 10, 2,  59, 51, 43, 35,
                27, 19, 11, 3,  60, 52, 44, 36, 63, 55,
                47, 39, 31, 23, 15, 7,  62, 54, 46, 38,
                30, 22, 14, 6,  61, 53, 45, 37, 29, 21,
                13, 5,  28, 20, 12, 4 };
 
        // second key-Permutation Table
        int[] PC2
            = { 14, 17, 11, 24, 1,  5,  3,  28, 15, 6,
                21, 10, 23, 19, 12, 4,  26, 8,  16, 7,
                27, 20, 13, 2,  41, 52, 31, 37, 47, 55,
                30, 40, 51, 45, 33, 48, 44, 49, 39, 56,
                34, 53, 46, 42, 50, 36, 29, 32 };
 
        // Expansion D-box Table
        int[] EP = { 32, 1,  2,  3,  4,  5,  4,  5,  6,  7,
                     8,  9,  8,  9,  10, 11, 12, 13, 12, 13,
                     14, 15, 16, 17, 16, 17, 18, 19, 20, 21,
                     20, 21, 22, 23, 24, 25, 24, 25, 26, 27,
                     28, 29, 28, 29, 30, 31, 32, 1 };
 
        // Straight Permutation Table
        int[] P
            = { 16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23,
                26, 5, 18, 31, 10, 2,  8,  24, 14, 32, 27,
                3,  9, 19, 13, 30, 6,  22, 11, 4,  25 };
 
        // S-box Table
        int[][][] sbox
            = { { { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6,
                    12, 5, 9, 0, 7 },
                  { 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12,
                    11, 9, 5, 3, 8 },
                  { 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7,
                    3, 10, 5, 0 },
                  { 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14,
                    10, 0, 6, 13 } },
 
                { { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13,
                    12, 0, 5, 10 },
                  { 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10,
                    6, 9, 11, 5 },
                  { 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6,
                    9, 3, 2, 15 },
                  { 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12,
                    0, 5, 14, 9 } },
                { { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7,
                    11, 4, 2, 8 },
                  { 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14,
                    12, 11, 15, 1 },
                  { 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12,
                    5, 10, 14, 7 },
                  { 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3,
                    11, 5, 2, 12 } },
                { { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5,
                    11, 12, 4, 15 },
                  { 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12,
                    1, 10, 14, 9 },
                  { 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3,
                    14, 5, 2, 8, 4 },
                  { 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11,
                    12, 7, 2, 14 } },
                { { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15,
                    13, 0, 14, 9 },
                  { 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15,
                    10, 3, 9, 8, 6 },
                  { 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5,
                    6, 3, 0, 14 },
                  { 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9,
                    10, 4, 5, 3 } },
                { { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4,
                    14, 7, 5, 11 },
                  { 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14,
                    0, 11, 3, 8 },
                  { 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10,
                    1, 13, 11, 6 },
                  { 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7,
                    6, 0, 8, 13 } },
                { { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7,
                    5, 10, 6, 1 },
                  { 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12,
                    2, 15, 8, 6 },
                  { 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6,
                    8, 0, 5, 9, 2 },
                  { 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15,
                    14, 2, 3, 12 } },
                { { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14,
                    5, 0, 12, 7 },
                  { 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11,
                    0, 14, 9, 2 },
                  { 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13,
                    15, 3, 5, 8 },
                  { 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0,
                    3, 5, 6, 11 } } };
        int[] shiftBits = { 1, 1, 2, 2, 2, 2, 2, 2,
                            1, 2, 2, 2, 2, 2, 2, 1 };
 
        // hexadecimal to binary conversion
        String hextoBin(String input)
        {
            int n = input.length() * 4;
            input = Long.toBinaryString(
                Long.parseUnsignedLong(input, 16));
            while (input.length() < n)
                input = "0" + input;
            return input;
        }
 
        // binary to hexadecimal conversion
        String binToHex(String input)
        {
            int n = (int)input.length() / 4;
            input = Long.toHexString(
                Long.parseUnsignedLong(input, 2));
            while (input.length() < n)
                input = "0" + input;
            return input;
        }
 
        // per-mutate input hexadecimal
        // according to specified sequence
        String permutation(int[] sequence, String input)
        {
            String output = "";
            input = hextoBin(input);
            for (int i = 0; i < sequence.length; i++)
                output += input.charAt(sequence[i] - 1);
            output = binToHex(output);
            return output;
        }
 
        // xor 2 hexadecimal strings
        String xor(String a, String b)
        {
            // hexadecimal to decimal(base 10)
            long t_a = Long.parseUnsignedLong(a, 16);
            // hexadecimal to decimal(base 10)
            long t_b = Long.parseUnsignedLong(b, 16);
            // xor
            t_a = t_a ^ t_b;
            // decimal to hexadecimal
            a = Long.toHexString(t_a);
            // prepend 0's to maintain length
            while (a.length() < b.length())
                a = "0" + a;
            return a;
        }
 
        // left Circular Shifting bits
        String leftCircularShift(String input, int numBits)
        {
            int n = input.length() * 4;
            int perm[] = new int[n];
            for (int i = 0; i < n - 1; i++)
                perm[i] = (i + 2);
            perm[n - 1] = 1;
            while (numBits-- > 0)
                input = permutation(perm, input);
            return input;
        }
 
        // preparing 16 keys for 16 rounds
        String[] getKeys(String key)
        {
            String keys[] = new String[16];
            // first key permutation
            key = permutation(PC1, key);
            for (int i = 0; i < 16; i++) {
                key = leftCircularShift(key.substring(0, 7),
                                        shiftBits[i])
                      + leftCircularShift(
                          key.substring(7, 14),
                          shiftBits[i]);
                // second key permutation
                keys[i] = permutation(PC2, key);
            }
            return keys;
        }
 
        // s-box lookup
        String sBox(String input)
        {
            String output = "";
            input = hextoBin(input);
            for (int i = 0; i < 48; i += 6) {
                String temp = input.substring(i, i + 6);
                int num = i / 6;
                int row = Integer.parseInt(
                    temp.charAt(0) + "" + temp.charAt(5),
                    2);
                int col = Integer.parseInt(
                    temp.substring(1, 5), 2);
                output += Integer.toHexString(
                    sbox[num][row][col]);
            }
            return output;
        }
 
        String round(String input, String key, int num)
        {
            // fk
            String left = input.substring(0, 8);
            String temp = input.substring(8, 16);
            String right = temp;
            // Expansion permutation
            temp = permutation(EP, temp);
            // xor temp and round key
            temp = xor(temp, key);
            // lookup in s-box table
            temp = sBox(temp);
            // Straight D-box
            temp = permutation(P, temp);
            // xor
            left = xor(left, temp);
            System.out.println("Round " + (num + 1) + " "
                               + right.toUpperCase() + " "
                               + left.toUpperCase() + " "
                               + key.toUpperCase());
 
            // swapper
            return right + left;
        }
 
        String encrypt(String plainText, String key)
        {
            int i;
            // get round keys
            String keys[] = getKeys(key);
 
            // initial permutation
            plainText = permutation(IP, plainText);
            System.out.println("After initial permutation: "
                               + plainText.toUpperCase());
            System.out.println(
                "After splitting: L0="
                + plainText.substring(0, 8).toUpperCase()
                + " R0="
                + plainText.substring(8, 16).toUpperCase()
                + "\n");
 
            // 16 rounds
            for (i = 0; i < 16; i++) {
                plainText = round(plainText, keys[i], i);
            }
 
            // 32-bit swap
            plainText = plainText.substring(8, 16)
                        + plainText.substring(0, 8);
 
            // final permutation
            plainText = permutation(IP1, plainText);
            return plainText;
        }
 
        String decrypt(String plainText, String key)
        {
            int i;
            // get round keys
            String keys[] = getKeys(key);
 
            // initial permutation
            plainText = permutation(IP, plainText);
            System.out.println("After initial permutation: "
                               + plainText.toUpperCase());
            System.out.println(
                "After splitting: L0="
                + plainText.substring(0, 8).toUpperCase()
                + " R0="
                + plainText.substring(8, 16).toUpperCase()
                + "\n");
 
            // 16-rounds
            for (i = 15; i > -1; i--) {
                plainText
                    = round(plainText, keys[i], 15 - i);
            }
 
            // 32-bit swap
            plainText = plainText.substring(8, 16)
                        + plainText.substring(0, 8);
            plainText = permutation(IP1, plainText);
            return plainText;
        }
    }
 
    // Driver code
    public static void main(String args[])
    {
        String text = "123456ABCD132536";
        String key = "AABB09182736CCDD";
 
        DES cipher = new DES();
        System.out.println("Encryption:\n");
        text = cipher.encrypt(text, key);
        System.out.println(
            "\nCipher Text: " + text.toUpperCase() + "\n");
        System.out.println("Decryption\n");
        text = cipher.decrypt(text, key);
        System.out.println("\nPlain Text: "
                           + text.toUpperCase());
    }
}

#rsa
import java.math.*;
import java.util.*;

public class Main
{
	public static void main(String args[]) {
		int p, q, n, z, d=0, e, i;
		int msg = 25;
		double c;
		BigInteger msgback;
		p = 3; //first prime number
		q = 11; //second prime number
		n = p*q;
		z = (p-1) * (q-1);
		System.out.println("Message to be encrypted is: " + msg);
		System.out.println("Value of z = " + z);

		for (e=2; e < z; e++) {
			if (gcd(e, z) == 1)
				break;
			// e is for public key exponent
		}
		System.out.println("Value of e = " + e);
		for (i=0; i <=9; i++) {
			int x = 1 + (i*z);

			//d is for private key component
			if (x%e==0) {
				d = x/e;
				break;
			}
		}

		System.out.println("Value of d = " + d);
		c = (Math.pow(msg, e)) % n;
		System.out.println("Encrypted message is: " + c);

		//converting int value of n to BigInteger
		BigInteger N = BigInteger.valueOf(n);
		//converting float value of c to BigInteger
		BigInteger C = BigDecimal.valueOf(c).toBigInteger();
		msgback = (C.pow(d)).mod(N);
		System.out.println("Decrypted message is: " + msgback);
	}

	static int gcd(int e, int z) {
		if (e==0)
			return z;
		else
			return gcd(z%e, e);
	}
}

#diffie hellman
import java.math.*;
import java.util.*;
public class Main {
	private static long power(long a, long b, long p) {
		if (b==1)
			return a;
		else
			return(((long)Math.pow(a, b)) % p);
	}

	public static void main(String[] args) {
		long P, G, a, b, x, y, ka, kb;
		//Both persons will agree upon public key G and P

		//prime number P is taken
		P = 23;

		//primitive root for P, G is taken
		G = 9;
		System.out.println("Value of P = " + P);
		System.out.println("Value of G = " + G); 

		//Alice will choose private key a
		a = 4;
		System.out.println("The private key a for Alice is " + a);
		//Bob will choose private key b
		b = 3;
		System.out.println("The private key for Bob is " + b);
        x = power(G, a, P);
		y = power(G, b, P); //generated key

		//Generating secret key after exchange of keys
		ka = power(y, a, P); // secret key for Alice
		kb = power(x, b, P); //secret key for Bob

		System.out.println("Secret key for Alice is: " + ka);
		System.out.println("Secret key for Bob is: " + kb);
	}
}

#MD5
import java.math.*;
import java.util.*;
import java.security.*;

public class Main {
	private static String getMd5(String input) {
		try {
		    //static getInstance method is called with hashing md5
		    MessageDigest md = MessageDigest.getInstance("MD5");
		    //digest() is called to calculate message digest
		    byte[] messageDigest = md.digest(input.getBytes());
		    
		    //convert byte array into signum representation
		    BigInteger no = new BigInteger(1, messageDigest);
		    
		    //convert message digest into hex value
		    String hashtext = no.toString(16);
		    while (hashtext.length() < 32) {
		        hashtext = "0" + hashtext;
		    } 
		    return hashtext;
		}
		
		//for specifying wrong message digest algorithms
		catch (NoSuchAlgorithmException e) {
		    throw new RuntimeException(e);
		}
	}

	public static void main(String[] args) {
		String s = "Generate Message Digest";
		System.out.println("Your HashCode generated by MD5 is: " + getMd5(s));
	}
}

#HMAC_SHA1
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SignatureException;
import java.util.Formatter;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class HmacSha1Signature {
	private static final String HMAC_SHA1_ALGORITHM = "HmacSHA1";
	private static String toHexString(byte[] bytes) {
		Formatter formatter = new Formatter();
		
		for (byte b : bytes) {
			formatter.format("%02x", b);
		}
		return formatter.toString();
	}
	public static String calculateRFC2104HMAC(String data, String key)
		throws SignatureException, NoSuchAlgorithmException, InvalidKeyException
	{
		SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);
		Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
		mac.init(signingKey);
		return toHexString(mac.doFinal(data.getBytes()));
	}
	public static void main(String[] args) throws Exception {
		String hmac = calculateRFC2104HMAC("data", "key");
		System.out.println(hmac);
	}
}

#aes
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import java.util.Base64;

public class pencil {
    private SecretKey key;
    private final int KEY_SIZE = 128;
    private final int DATA_LENGTH = 128;
    private Cipher encryptionCipher;

    public void init() throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        keyGenerator.init(KEY_SIZE);
        key = keyGenerator.generateKey();
    }
    
    public String encrypt(String data) throws Exception {
        byte[] dataInBytes = data.getBytes();
        encryptionCipher = Cipher.getInstance("AES/GCM/NoPadding");
        encryptionCipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] encryptedBytes = encryptionCipher.doFinal(dataInBytes);
        return encode(encryptedBytes);
    }
    
    public String decrypt(String encryptedData) throws Exception {
        byte[] dataInBytes = decode(encryptedData);
        Cipher decryptionCipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(DATA_LENGTH, encryptionCipher.getIV());
        decryptionCipher.init(Cipher.DECRYPT_MODE, key, spec);
        byte[] decryptedBytes = decryptionCipher.doFinal(dataInBytes);
        return new String(decryptedBytes);
    }
    
    private String encode(byte[] data) {
        return Base64.getEncoder().encodeToString(data);
    }

    private byte[] decode(String data) {
        return Base64.getDecoder().decode(data);
    }

    public static void main(String[] args) {
        try {
            pencil aes_encryption = new pencil();
            aes_encryption.init();
            String encryptedData = aes_encryption.encrypt("Hello, welcome to the encryption world");
            String decryptedData = aes_encryption.decrypt(encryptedData);

            System.out.println("Encrypted Data : " + encryptedData);
            System.out.println("Decrypted Data : " + decryptedData);
        } catch (Exception ignored) {
        }
    }
}

#firewall
